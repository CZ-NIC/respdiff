#!/bin/bash
set -o xtrace

JOBNAME=j$1.$2

# HACK (condor): ensure files for transfer exist to avoid held jobs
touch ${JOBNAME}_report.json
touch ${JOBNAME}_report.txt
touch ${JOBNAME}_histogram.svg

# Check no other docker containers are running
if [ -n "$(docker ps -q)" ]; then
	exit 2
fi

# Ensure ports are empty, so we're not testing something else!
MAX_RETRIES=60
{% for resolver in resolvers.values() -%}
retries=0
{% if resolver['port'] %}
while netstat -antu | grep -q ":{{ resolver['port'] }}"; do
	retries=$((retries+1))
	if (( $retries > $MAX_RETRIES )); then
		exit 2
	fi
	sleep 1
done
{% endif %}
{% if resolver['tls_port'] %}
retries=0
while netstat -antu | grep -q ":{{ resolver['tls_port'] }}"; do
	retries=$((retries+1))
	if (( $retries > $MAX_RETRIES )); then
		exit 2
	fi
	sleep 1
done
{% endif %}
{% endfor %}

# Exit if any cmd fails from now on.
set -o errexit

cleanup() {
	docker-compose rm -fsv || :
{%if database['remove_after'] %}
	rm -rf ./*.mdb || :
{% endif %}
	exit 0
}
trap cleanup ERR EXIT

# Get database
wget --quiet -O {{ database['dest'] }} {{ database['url'] }}

# Attempt to build containers (to have stdout/err logs in case of failure)
time docker-compose up --no-start
# Start and wait for resolvers to be available
./restart-all.sh

# Run respdiff toolchain
time "{{ respdiff['srcdir'] }}/orchestrator.py" .
docker-compose stop  # give lingering connections time to close
time "{{ respdiff['srcdir'] }}/msgdiff.py" -d ${JOBNAME}_report.json .
time "{{ respdiff['srcdir'] }}/diffrepro.py" -d ${JOBNAME}_report.json .
time "{{ respdiff['srcdir'] }}/diffsum.py" -d ${JOBNAME}_report.json . > ${JOBNAME}_report.txt
time "{{ respdiff['srcdir'] }}/histogram.py" -o ${JOBNAME}_histogram.svg .
